<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Foreign Data Wrapper sous PostgreSQL</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


				<section id="title">
					<h1>Foreign Data Wrapper</h1>
					<h2>ou un réseau social pour vos données</h2>
					<h2>sous PostgreSQL</h2>
				</section>


				<section id="qui-suis-je">
					<h1>Qui suis-je ?</h1>

					<div class="flex-row">
						<div>
							<img id="avatar" class="clean-image" src="./assets/img/my-disk-world.png" alt="avatar" />
						</div>
						<div class="flex-element-centered">
							<div class="name">Florian FERRIERE</div>
							<br />
							<div class="twitter">
								<a href="https://twitter.com/FerriereFlorian">@FerriereFlorian</a>
							</div>
						</div>
					</div>

					<div>
						<div>
							Développeur chez Norsys
						</div>
						<div>
							<img id="logo-norsys" src="./assets/img/norsys.png" alt="norsys" />
						</div>
					</div>
				</section>

                <section>

                    <section>
                        <div>
                            <div>
                                <img id="logo-postgresql" class="clean-image" src="./assets/img/postgresql.png" alt="postgresql" />
                            </div>

                            <h1>
                                PostgreSQL
                            </h1>
                        </div>
                    </section>

                    <section class="historique">
                        <h1>Historique</h1>

                        <p class="fragment">1974 : Création d'Ingres</p>
                        <p class="fragment">1985 : Refonte de zéro d'Ingres pour créer <i>postgres</i></p>
                        <p class="fragment">1995 : Ajout des fonctionnalités SQL => Postgres 95</p>
                        <p class="fragment">1996 : Renommage en PostreSQL</p>
                        <p class="fragment">Aujourd'hui version 9.5</p>

                        <aside class="notes">
                            <ul>
                                <li>PostgreSQL est une base de données dont les origines commencent en 1974
                                    avec la création d'Ingres par Michael Stonebraker.</li>
                                <li>En 1985, il entamme une refonte à partir de zéro d'Ingres, intitulé postgres,
                                    qui est le diminutif de "post-Ingres".</li>
                                <li>Un tournant important arrive en 1995 avec l'ajout des fonctionnalités liés au SQL.
                                    Le projet fut alors renommé "Postgres 95"</li>
                                <li>1 an plus tard, il devient alors "PostgreSQL".</li>
                                <li>Beaucoup de travaux plus tard ont pu donner la version 9.5 dernière version stable à ce jour.</li>
                            </ul>
                        </aside>
                    </section>

                    <section class="fonctionnalites_generales">
                        <h1>Fonctionnalités générales</h1>

                        <ul>
                            <li class="fragment">SGBDR</li>
                            <li class="fragment">Accessible : JDBC, pgsql</li>
                            <li class="fragment">
                                SQL Avancé :
                                <ul>
                                    <li class="fragment">Trigger</li>
                                    <li class="fragment">Common Table Expressions</li>
                                    <li class="fragment">Vue et Vue matérialisée</li>
                                    <li class="fragment">...</li>
                                </ul>
                            </li>
                            <li class="fragment">PostGIS</li>
                            <li class="fragment">...</li>
                            <li class="fragment">Foreign Data Wrapper</li>
                        </ul>

                        <aside class="notes">
                            <ul>
                                <li>Server de Gestion de Base de Données Relationnel Objet</li>
                                <li>
                                    Accessible avec plein de language de programation :
                                        - JDBC pour JAVA
                                        - lib pgsql pour PHP
                                </li>
                                <li>SQL Avancé</li>
                                <li>
                                    PostGIS : gestion des objets Spatiaux et Géographique.
                                    Utilisé par OpenStreetMap.
                                </li>
                                <li>...</li>
                                <li>Foreign Data Wrapper</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h1>Foreign Data Wrapper</h1>
                        <h2>Qu'est-ce que c'est ?</h2>

                        <p class="fragment">Norme SQL/MED (Management of External Data)</p>
                        <p class="fragment">Créée en 2003</p>
                        <p class="fragment">
                            <br />
                            Création de wrapper :
                            <ul>
                                <li class="fragment">Nativement en C</li>
                                <li class="fragment">En python avec "Multicorn"</li>
                                <li class="fragment">En ruby avec "Holycorn"</li>
                            </ul>
                        </p>

                        <aside class="notes">
                            Le Foreign Data Wrapper est une implémentation de la norme SQL/MED
                            (Management of External Data), créée en 2003.
                            Comme son nom l'indique, cette norme permet la gestion des données externes,
                            depuis un autre SGBD ou des sources diverses.
                            Il est possible de créer son propre wrapper en C en utilisant
                            les fonctions prévues à cet effet.
                            Des extensions comme "Multicorn" en python ou "Holycorn" en ruby
                            ont été crées pour facilité la création de wrapper.
                            Grace à ça, il existe, à ce jour, un nombre important de wrapper.
                        </aside>
                    </section>

                    <section>
                        <h1>Quelques Wrapper</h1>

                        <p class="fragment">PostgreSQL</p>
                        <p class="fragment">SGBD SQL courants : MySQL, Oracle, MSSQL, SQLite, ...</p>
                        <p class="fragment">Connecteurs SQL génériques : ODBC, JDBC</p>
                        <p class="fragment">NoSQL : MongoDB, Cassandra, Redis, ...</p>
                        <p class="fragment">
                            <br />
                            CSV, XML, LDAP
                        </p>
                        <p class="fragment">
                            Git,
                            <span class="fragment">Logs,</span>
                            <span class="fragment">WWW,</span>
                            <span class="fragment">IMAP</span>
                        </p>
                        <p class="fragment">
                            Processus,
                            <span class="fragment">Twitter,</span>
                            <span class="fragment">Docker,</span>
                            <span class="fragment">...</span>
                        </p>

                        <aside class="notes">
                            <ul>
                                <li>Forcément nous avons la possibilité de connecté un serveur PostgreSQL avec un autre.</li>
                                <li>Mais également avec d'autres SGBD.</li>
                                <li>Soit avec les connecteurs natifs</li>
                                <li>Soit avec des connecteurs génériques</li>
                                <li>Il est aussi possible de dialoguer avec des serveurs NoSQL.</li>
                                <li>Il y a aussi des connecteurs vers des fichiers CSV, XML ou un serveur LDAP</li>
                                <li>Ou encore des systèmes plus atypiques comme Git, les logs systèmes, des services web ou des mails via le protocol IMAP</li>
                                <li>Et pourquoi pas la liste des processus du système, votre timeline twitter</li>
                                <li>Et même une connexion avec le serveur docker pour lister les containeurs ou les images</li>
                                <li>Et tant d'autre</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h1>Évolution</h1>
                        <div>
                            <p class="fragment"><strong>07/2009 : v8.4</strong> => Démarrage de l'implémentation du SQL/MED</p>
                            <p class="fragment"><strong>09/2011 : v9.1</strong> => Arrivée des "Foreign Tables"</p>
                            <p class="fragment">
                                <strong>09/2013 : v9.3</strong><br />
                                Ajout de l'écriture sur les Foreign Tables<br />
                                Ajout du type json
                            </p>
                            <p class="fragment">
                                <strong>10/2014 : v9.4</strong><br />
                                Ajout des triggers sur les Foreign Tables<br />
                                Ajout du type jsonb
                            </p>
                        </div>

                        <aside class="notes">
                            <ul>
                                <li>C'est en Juillet 2009 que nous avons pu voir arriver l'implémentation du SQL/MED. Les prémices du FDW ont commencés</li>
                                <li>Septembre 2011 sont arrivés les Foreign Tables. Fondement pour l'utilisation de SGBD distant.</li>
                                <li>
                                    Depuis Septembre 2013 nous avons la possibilité d'écrire sur les tables distantes.
                                    Une autre nouveauté, que je trouve importante, est l'arrivé du type json.
                                </li>
                                <li>
                                    En Octobre 2014, les triggers sur les tables distantes ont été ajoutés au panel des fonctionnalités.
                                    Ainsi que le type jsonb, ce type est, cette fois, indexable, contrairement au json.
                                </li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h1>Évolution</h1>

                        <div>
                            <p class="fragment">
                                <strong>01/2016 : v9.5</strong><br />
                                IMPORT FOREIGN SCHEMA<br />
                                <i>INSERT ... ON CONFLICT DO NOTHING<span class="fragment highlight-line-through">/UPDATE</span></i>
                            </p>
                            <p class="fragment">
                                <strong>T3/2016 : v9.6</strong><br />
                                JOIN et SORT directement sur le serveur distant<br />
                                UPDATE et DELETE avec une meilleure gestion des transactions<br />
                                Possibilité d'annuler une requête distante
                            </p>
                        </div>

                        <aside class=notes>
                            <ul>
                                <li>
                                    De puis Janvier de cette année il est possible d'importé un schema distant plutôt que de créer les différentes tables distantes.
                                    La version 9.5 apporte aussi la commande INSERT ... ON CONFLICT DO NOTHING ou UPDATE.
                                    Cette commande permet d'éviter les erreurs en cas d'insertion d'une ligne créant un doublon sur un champ unique.
                                    Il est possible de ne rien faire ou d'éxécuter une commande UPDATE.
                                    La commande est aussi disponible sur les tables distantes mais uniquement avec le NOTHING.
                                </li>
                                <li>
                                    La prochaine version est prévue pour le troisième trimestre et apportera :
                                    <ul>
                                        <li>une amélioration pour faire le JOIN et le SORT directement sur le serveur distant</li>
                                        <li>l'amélioration de la gestion des transactions pour les UPDATE et les DELETE</li>
                                        <li>la possibilité d'annuler une requête distante</li>
                                    </ul>
                                </li>
                            </ul>
                        </aside>
                    </section>

                </section>

                <section>
                    <h1>Cas d'utilisation</h1>

                    <section>
                        <h2>Décentralisation</h2>

                        <img id="pic-decentralisation" src="assets/img/decentralisation.png" alt="décentralisation" />

                        <aside class="notes">
                            Le premier cas d'utilisation qui m'est venu en tête et que j'ai pu mettre en pratique,
                            est une utilisation décentraliser. Nous avons deux serveurs de bases de données.
                            Le premier contient la totalité des données.
                            Le second tout ou partie de ces données pour les rendre accessible à un serveur web.
                        </aside>
                    </section>

                    <section>
                        <h2>CQRS/ES</h2>

                        <img id="pic-cqrs-es" src="assets/img/cqrs_es.png" alt="CQRS/ES" />

                        <aside class="notes">
                            Nous pouvons imaginer utiliser le FDW avec le CQRS/ES.
                            Nous partons sur le même principe que le cas précédent
                            mais les données sources sont enregistrés sous le type d'événement.
                            Le type json(b) pourra ici nous être très utile.
                        </aside>
                    </section>

                    <section>
                        <h2>CQRS/ES Multiple</h2>

                        <img id="pic-cqrs-es-multiple" src="assets/img/cqrs_es_multiple.png" alt="CQRS/ES" />

                        <aside class="notes">
                            Ce cas n'est autre qu'un dérivé du précédent.
                            Par contre, là avons une séparation par métier.
                            Cela permet d'avoir une base commune (l'event store)
                            et les autres bases qui elles seront utilisées
                            par les applications qui pourront être hébergées dans des endroits différents.

                            Il est tout à fait possible d'avoir ce côté, multi-serveur avec des tables standards
                            comme dans le cas "décentralisé".
                        </aside>
                    </section>
                </section>

                <section>
                    <h1>Comment ça marche ?</h1>

                    <section>
                        <h2>Déclaration de la connexion</h2>

                        <pre><code class="hlsql">
    CREATE EXTENSION postgres_fdw;
                        </code></pre>

                        <aside class="notes">
                            On déclare l'extension pour pouvoir l'utiliser dans PostgreSQL.
                            /!\ Nécessite certains droits utilisateurs.
                        </aside>
                    </section>

                    <section>
                        <h2>Création de la connexion</h2>

                        <pre><code class="hlsql">
    CREATE SERVER nom_remote
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'remote.url.lan',
        dbname 'ma_db'
    );
                        </code></pre>

                        <aside class="notes">
                            On créer le serveur distant.
                            D'autres options comme le port de connexion existent.
                        </aside>
                    </section>
                    <section>
                        <h2>Mapping utilisateur</h2>

                        <pre><code class="hlsql">
    CREATE USER MAPPING FOR mon_local_user
        SERVER mon_remote
        OPTIONS (
            user 'mon_remote_user',
            password 'mon_remote_passwd'
        );
                        </code></pre>

                        <aside class="notes">
                            Les comptes utilisateurs ne sont pas forcément les mêmes
                            entre les deux instances.
                            Nous devons donc mapper notre utisateur local avec l'utilisateur distant.
                        </aside>
                    </section>

                    <section>
                        <h2>Création d'une table distante</h2>

                        <pre><code class="hlsql">
    CREATE FOREIGN TABLE table_locale_mais_distante (
        id INTEGER,
        col1 VARCHAR(32),
        col2 BOOLEAN
    )
    SERVER mon_remote
    OPTIONS (
        table_name 'le_nom_de_ma_table',
        updatable 'false'
    );
                        </code></pre>

                        <aside class="notes">
                            La création d'une table étrangère se fait presque comme une table normale.
                            En plus du mot clef "FOREIGN"
                            nous devons spécifié le serveur sur lequelle est la table ainsi que quelques options.
                            Par défaut les tables distantes sont modifiables et le schema est 'public'.
                        </aside>
                    </section>

                    <section>
                        <h2>Utilisation</h2>

                        <pre><code class="hlsql">
    SELECT id, col1
    FROM table_locale_mais_distante
    WHERE col2 IS TRUE
    ORDER BY col1;
                        </code></pre>

                        <aside class="notes">
                            Une fois la table correctement créée,
                            l'utilisation est la même qu'avec une table standard.
                        </aside>
                    </section>

                </section>

                <section>
                    <h1>Exemple</h1>

                    <section>

                        <p>
                            <a href="https://github.com/fferriere/20160622_presentation_pg_fdw">Projet Github</a>
                            <br />
                            <i>Server</i> = "Base principale"
                            <br />
                            <i>Client</i> = "Web DB"
                        </p>

                        <aside class="notes">
                            J'ai créer un projet avec 2 conteneurs docker
                            pour montrer l'utilisation des foreign data wrapper.
                            Le README.md explique comment l'utiliser.

                            Les exemples suivants sont tirés de ce projet.
                        </aside>

                    </section>

                    <section>
                        <h2>Tables sur <i>server</i></h2>

                        <pre><code class="hlsh">
    server=# \d
                    Liste des relations
     Schéma |       Nom       |   Type   | Propriétaire
    --------+-----------------+----------+--------------
     public | country         | table    | docker
     public | country_id_seq  | séquence | docker
     public | customer        | table    | docker
     public | customer_id_seq | séquence | docker
    (4 lignes)
                        </code></pre>

                        <aside class="notes">
                            Voici la liste des tables sur le serveur.
                            Nous avons une table country et une autre customer
                            ainsi que les sequence associée.
                        </aside>

                    </section>

                    <section>
                        <h2>Table sur le <i>server</i></h2>

                        <pre><code class="hlsh">
    server=# \d country
                  Table « public.country »
     Colonne |         Type          | Modificateurs
    ---------+-----------------------+---------------
     id      | integer               | non NULL
     alpha2  | character(2)          | non NULL
     alpha3  | character(3)          | non NULL
     label   | character varying(64) | non NULL
    Index :
        "country_pkey" PRIMARY KEY, btree (id)
                        </code></pre>
                    </section>

                    <section>
                        <h2>Table sur le <i>server</i></h2>

                        <pre><code class="hlsh">
    server=# SELECT count(id) FROM country;
     count
    -------
       241
    (1 ligne)

    server=# SELECT id, alpha2, alpha3, label
            FROM public.country
            WHERE alpha2 = 'FR';
     id | alpha2 | alpha3 | label
    ----+--------+--------+--------
     75 | FR     | FRA    | France
    (1 ligne)
                        </code></pre>

                        <aside class="notes">
                            Nous pouvons voir qu'il y a des données.
                        </aside>
                    </section>

                    <section>
                        <h2>Tables sur le <i>client</i></h2>

                        <pre><code class="hlsh">
    client=# \d
                    Liste des relations
    Schéma |    Nom     |       Type       | Propriétaire
    --------+------------+------------------+--------------
    public | f_country  | table distante   | docker
    public | f_customer | table distante   | docker
    public | m_customer | vue matérialisée | docker
    public | u_country  | table distante   | docker
    (4 lignes)
                        </code></pre>

                        <aside class="notes">
                            Ici nous avons listé les tables sur le client.
                            J'ai pour habitude de préfixer les tables étrangères par un f.
                            Pour l'exemple j'ai créer la table u_country,
                            c'est la même table que f_country mais updatable.
                            Nous pouvons voir qu'il y a une vue matériliasée.
                            Nous reviendrons dessus.
                        </aside>
                    </section>

                    <section>
                        <h2>Table sur le <i>client</i></h2>

                        <pre><code class="hlsh">
    client=# \d f_country
                  Table distante « public.f_country »
     Colonne |         Type          | Modificateurs | Options FDW
    ---------+-----------------------+---------------+-------------
     id      | integer               |               |
     alpha2  | character(2)          |               |
     alpha3  | character(3)          |               |
     label   | character varying(64) |               |
    Server: remote
    FDW Options: (schema_name 'public', table_name 'country', updatable 'false')
                        </code></pre>

                        <aside class="notes">
                            Nous avons une description de la table f_country,
                            à l'image de la table sur server.
                        </aside>
                    </section>

                    <section>
                        <h2>Table sur le <i>client</i></h2>

                        <pre><code class="hlsh">
    client=# SELECT count(id) FROM f_country;
     count
    -------
       241
    (1 ligne)

    client=# SELECT id, alpha2, alpha3, label
            FROM public.f_country
            WHERE alpha2 = 'FR';
     id | alpha2 | alpha3 | label
    ----+--------+--------+--------
     75 | FR     | FRA    | France
    (1 ligne)
                        </code></pre>

                        <aside class="notes">
                            Nous pouvons voir qu'il y a les même données.
                        </aside>
                    </section>

                    <section>
                        <h2>Vue matérialisée</h2>

                        <pre><code class="hlsql">
    CREATE MATERIALIZED VIEW m_customer AS
    SELECT id, lastname, firstname,
            date_part('year', age(birthday)) as age
    FROM f_customer
    WITH NO DATA;
    CREATE INDEX m_customer_keys
        ON m_customer (id);
    REFRESH MATERIALIZED VIEW m_customer;
                        </code></pre>

                        <aside class="notes">
                            Nous avons, ici, la requête de création de vue matérialisées.
                            Une vue matérialisées est entre une table et une vue.
                            La construction ce fait, comme une vue, à partir d'une requête.
                            Par contre les données sont stockées.
                            Ce qui fait que l'on peut ajouter des index.
                            Le fait d'avoir une construction par requête permet
                            de spécialiser les informations pour notre besoin.
                        </aside>
                    </section>

                    <section>
                        <h2>Vue matérialisées</h2>

                        <pre><code class="hlsh">
    server=# SELECT id, lastname, firstname, birthday
            FROM customer LIMIT 2;
     id | lastname | firstname |  birthday
    ----+----------+-----------+------------
      1 | Potter   | Harry     | 1980-08-31
      2 | Weasley  | Ron       | 1980-03-01
    (2 lignes)

    client=# SELECT id, lastname, firstname, age
            FROM m_customer LIMIT 2;
     id | lastname | firstname | age
    ----+----------+-----------+-----
      1 | Potter   | Harry     |  35
      2 | Weasley  | Ron       |  36
    (2 lignes)
                        </code></pre>

                        <aside class="notes">
                            Nous pouvons voir que la vue matérialisée
                            retourne bien des données différentes
                            que la table initiale.
                        </aside>
                    </section>
                </section>

                <section>
                    <h1>Cas pratique</h1>

                    <section>
                        <h2>Besoin</h2>

                        <p class="fragment">Application Web</p>
                        <p class="fragment">IBM AS400/DB2</p>
                        <p class="fragment">
                            <span class="fragment highlight-line-through">Driver PHP</span>
                        </p>
                        <p class="fragment">JDBC</p>
                        <p class="fragment">jdbc2_fdw</p>

                        <aside class="notes">
                            Je vais maintenant vous parler du cas pratique que j'ai pu mettre en place.
                            Voici une étude du besoin.

                            Le besoin était d'avoir une application web,
                            permettant à nos clients d'accéder à leurs informations.

                            Les données sont stockées sur un IBM/AS400 qui intègre un base DB2.
                            Premier problème le driver PHP-DB2 n'est pas facilement accessible, en tout cas sous Linux.
                            OS de notre hébergement.
                            J'ai réussi, tant bien que mal à le compiler, mais une fois fais j'avais une erreur de license.
                            Bienvenue dans le monde merveilleux d'IBM.

                            J'avais pu remarquer qu'avec un outils de DB SQL générique développé en Java (DBeaver),
                            j'avais un connecteur JDBC pour DB2.
                            Après configuration j'ai pu facilement accéder aux données sur le serveur.

                            C'est là que j'ai découvert les FDW et le <a href="https://github.com/heimir-sverrisson/jdbc2_fdw/">jdbc2_fdw</a>.
                            Après quelques essais plutôt concluant je me suis lancé.
                        </aside>
                    </section>

                    <section>
                        <h2>Explication</h2>

                        <p></p>
                    </section>

                    <section>
                        <h2>Explication</h2>

                        <img id="as_400_proxy_web" src="assets/img/as_400_proxy_web.png" alt="as_400_proxy_web" />
                    </section>
                </section>

                <section>
                    <h1>Merci</h1>

                    <h2>Des questions ?</h2>
                </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                slideNumber: 'c/t',

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
