<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Foreign Data Wrapper sous PostgreSQL</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/idea.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


                <section id="title">
                <h1>Foreign Data Wrapper</h1>
                <h2>ou un réseau social pour vos données</h2>
                <h2>sous PostgreSQL</h2>
                </section>


                <section id="qui-suis-je">
                	<h1>Qui suis-je ?</h1>

                	<div class="flex-row">
                		<div>
                			<img id="avatar" class="clean-image" src="./assets/img/my-disk-world.png" alt="avatar" />
                		</div>
                		<div class="flex-element-centered">
                			<div class="name">Florian FERRIERE</div>
                			<div class="twitter">
                				<a href="https://twitter.com/FerriereFlorian">@FerriereFlorian</a>
                			</div>
                		</div>
                	</div>

                	<div>
                		<div>
                			Développeur chez Norsys
                		</div>
                		<div>
                			<img id="logo-norsys" src="./assets/img/norsys.png" alt="norsys" />
                		</div>
                	</div>
                </section>

                <section id="pg_en_3_mots">

                    <section id="postgresql">
                        <div>
                            <div>
                                <img id="logo-postgresql" class="clean-image" src="./assets/img/postgresql.png" alt="postgresql" />
                            </div>

                            <h1>
                                PostgreSQL
                            </h1>
                        </div>
                    </section>

                    <section id="historique">
                        <h1>Historique</h1>

                        <p class="fragment">1974 : Création d'Ingres</p>
                        <p class="fragment">1985 : Refonte de zéro d'Ingres pour créer <i>postgres</i></p>
                        <p class="fragment">1995 : Ajout des fonctionnalités SQL => Postgres 95</p>
                        <p class="fragment">1996 : Renommage en PostgreSQL</p>
                        <p class="fragment">2016 : Version 9.5</p>

                        <aside class="notes">
                            <ul>
                                <li>PostgreSQL est une base de données dont les origines commencent en 1974
                                    avec la création d'Ingres par Michael Stonebraker.</li>
                                <li>En 1985, il entamme une refonte à partir de zéro d'Ingres, intitulé postgres,
                                    qui est le diminutif de "post-Ingres".</li>
                                <li>Un tournant important arrive en 1995 avec l'ajout des fonctionnalités liés au SQL.
                                    Le projet fut alors renommé "Postgres 95"</li>
                                <li>1 an plus tard, il devient alors "PostgreSQL".</li>
                                <li>Beaucoup de travaux plus tard ont pu donner la version 9.5 dernière version stable à ce jour.</li>
                            </ul>
                        </aside>
                    </section>

                    <section id="fonctionnalites_generales">
                        <h1>Fonctionnalités générales</h1>

                        <ul>
                            <li class="fragment">SGBDRO</li>
                            <li class="fragment">Accessible : JDBC, pgsql, ...</li>
                            <li class="fragment">
                                SQL Avancé :
                                <ul>
                                    <li class="fragment">Triggers</li>
                                    <li class="fragment">Common Table Expressions</li>
                                    <li class="fragment">Vues et Vues matérialisées</li>
                                    <li class="fragment">...</li>
                                </ul>
                            </li>
                            <li class="fragment">PostGIS</li>
                            <li class="fragment">...</li>
                            <li class="fragment">Foreign Data Wrapper</li>
                        </ul>

                        <aside class="notes">
                            <ul>
                                <li>Server de Gestion de Base de Données Relationnel Objet</li>
                                <li>
                                    Accessible avec plein de language de programation :
                                        - JDBC pour JAVA
                                        - lib pgsql pour PHP
                                </li>
                                <li>SQL Avancé</li>
                                <li>
                                    PostGIS : gestion des objets Spatiaux et Géographique.
                                    Utilisé par OpenStreetMap.
                                </li>
                                <li>...</li>
                                <li>Foreign Data Wrapper</li>
                            </ul>
                        </aside>
                    </section>

                </section>

                <section id="foreign_data_wrapper">

                    <section id="fdw_explication">
                        <h1>Foreign Data Wrapper</h1>
                        <h2>Qu'est-ce que c'est ?</h2>

                        <p class="fragment">Norme SQL/MED (Management of External Data)</p>
                        <p class="fragment">Créée en 2003</p>
                        <p id="creation_wrapper" class="fragment">
                            Création de wrapper :
                            <ul>
                                <li class="fragment">Nativement en C</li>
                                <li class="fragment">En python avec "Multicorn"</li>
                                <li class="fragment">En ruby avec "Holycorn"</li>
                            </ul>
                        </p>

                        <aside class="notes">
                            Le Foreign Data Wrapper est une implémentation de la norme SQL/MED
                            (Management of External Data), créée en 2003.
                            Comme son nom l'indique, cette norme permet la gestion des données externes,
                            depuis un autre SGBD ou des sources diverses.
                            Il est possible de créer son propre wrapper en C en utilisant
                            les fonctions prévues à cet effet.
                            Des extensions comme "Multicorn" en python ou "Holycorn" en ruby
                            ont été crées pour facilité la création de wrapper.
                            Grace à ça, il existe, à ce jour, un nombre important de wrapper.
                        </aside>
                    </section>

                    <section id="wrappers_list">
                        <h1>Quelques Wrappers</h1>

                        <div id="SGDB_fdw">
                            <p class="fragment">PostgreSQL</p>
                            <p class="fragment">SGBD SQL courants : MySQL, Oracle, SQL Server, SQLite, ...</p>
                            <p class="fragment">Connecteurs SQL génériques : ODBC, JDBC</p>
                            <p class="fragment">NoSQL : MongoDB, Cassandra, Redis, ...</p>
                        </div>
                        <div id="extra_fdw">
                            <p class="fragment">CSV, XML, LDAP</p>
                            <p class="fragment">Git, Logs, WWW, IMAP</p>
                            <p class="fragment">Processus, Twitter, Docker, ...</p>
                        </div>

                        <aside class="notes">
                            <ul>
                                <li>Forcément nous avons la possibilité de connecté un serveur PostgreSQL avec un autre.</li>
                                <li>Mais également avec d'autres SGBD.</li>
                                <li>Soit avec les connecteurs natifs</li>
                                <li>Soit avec des connecteurs génériques</li>
                                <li>Il est aussi possible de dialoguer avec des serveurs NoSQL.</li>
                                <li>Il y a aussi des connecteurs vers des fichiers CSV, XML ou un serveur LDAP</li>
                                <li>Ou encore des systèmes plus atypiques comme Git, les logs systèmes, des services web ou des mails via le protocol IMAP</li>
                                <li>Et pourquoi pas la liste des processus du système, votre timeline twitter</li>
                                <li>Et même une connexion avec le serveur docker pour lister les containeurs ou les images</li>
                                <li>Et tant d'autre</li>
                            </ul>
                        </aside>
                    </section>

                    <section id="evolution1">
                        <h1>Évolution (1/2)</h1>
                        <div>
                            <p class="fragment"><strong>07/2009 : v8.4</strong> => Démarrage de l'implémentation du SQL/MED</p>
                            <p class="fragment"><strong>09/2011 : v9.1</strong> => Arrivée des "Foreign Tables"</p>
                            <p class="fragment">
                                <strong>09/2013 : v9.3</strong><br />
                                Ajout de l'écriture sur les Foreign Tables<br />
                                Ajout du type json
                            </p>
                            <p class="fragment">
                                <strong>10/2014 : v9.4</strong><br />
                                Ajout des triggers sur les Foreign Tables<br />
                                Ajout du type jsonb
                            </p>
                        </div>

                        <aside class="notes">
                            <ul>
                                <li>C'est en Juillet 2009 que nous avons pu voir arriver l'implémentation du SQL/MED. Les prémices du FDW ont commencés</li>
                                <li>Septembre 2011 sont arrivés les Foreign Tables. Fondement pour l'utilisation de SGBD distant.</li>
                                <li>
                                    Depuis Septembre 2013 nous avons la possibilité d'écrire sur les tables distantes.
                                    Une autre nouveauté, que je trouve importante, est l'arrivé du type json.
                                </li>
                                <li>
                                    En Octobre 2014, les triggers sur les tables distantes ont été ajoutés au panel des fonctionnalités.
                                    Ainsi que le type jsonb, ce type est, cette fois, indexable, contrairement au json.
                                </li>
                            </ul>
                        </aside>
                    </section>

                    <section id="evolution2">
                        <h1>Évolution (2/2)</h1>

                        <div>
                            <p class="fragment">
                                <strong>01/2016 : v9.5</strong><br />
                                IMPORT FOREIGN SCHEMA<br />
                                <i>INSERT ... ON CONFLICT DO NOTHING<span class="fragment highlight-line-through">/UPDATE</span></i>
                            </p>
                            <p class="fragment">
                                <strong>T3/2016 : v9.6</strong><br />
                                JOIN et SORT directement sur le serveur distant<br />
                                UPDATE et DELETE avec une meilleure gestion des transactions<br />
                                Possibilité d'annuler une requête distante
                            </p>
                        </div>

                        <aside class=notes>
                            <ul>
                                <li>
                                    De puis Janvier de cette année il est possible d'importé un schema distant plutôt que de créer les différentes tables distantes.
                                    La version 9.5 apporte aussi la commande INSERT ... ON CONFLICT DO NOTHING ou UPDATE.
                                    Cette commande permet d'éviter les erreurs en cas d'insertion d'une ligne créant un doublon sur un champ unique.
                                    Il est possible de ne rien faire ou d'éxécuter une commande UPDATE.
                                    La commande est aussi disponible sur les tables distantes mais uniquement avec le NOTHING.
                                </li>
                                <li>
                                    La prochaine version est prévue pour le troisième trimestre et apportera :
                                    <ul>
                                        <li>une amélioration pour faire le JOIN et le SORT directement sur le serveur distant</li>
                                        <li>l'amélioration de la gestion des transactions pour les UPDATE et les DELETE</li>
                                        <li>la possibilité d'annuler une requête distante</li>
                                    </ul>
                                </li>
                            </ul>
                        </aside>
                    </section>

                </section>

                <section id="cas_utilisation">
                    <h1>Cas d'utilisation</h1>

                    <section id="vide">
                    </section>

                    <section id="decentralisation">
                        <h2>Décentralisation</h2>

                        <img id="pic-decentralisation" class="clean-image" src="assets/img/decentralisation.png" alt="décentralisation" />

                        <aside class="notes">
                            Le premier cas d'utilisation qui m'est venu en tête et que j'ai pu mettre en pratique,
                            est une utilisation décentraliser. Nous avons deux serveurs de bases de données.
                            Le premier contient la totalité des données.
                            Le second tout ou partie de ces données pour les rendre accessible à un serveur web.
                        </aside>
                    </section>

                    <section id="cqrs_es">
                        <h2>CQRS/ES</h2>

                        <img id="pic-cqrs-es" class="clean-image" src="assets/img/cqrs_es.png" alt="CQRS/ES" />

                        <aside class="notes">
                            Nous pouvons imaginer utiliser le FDW avec le CQRS/ES.
                            Nous partons sur le même principe que le cas précédent
                            mais les données sources sont enregistrés sous le type d'événement.
                            Le type json(b) pourra ici nous être très utile.
                        </aside>
                    </section>

                    <section id="cqrs_es_multiple">
                        <h2>CQRS/ES Multiple</h2>

                        <img id="pic-cqrs-es-multiple" class="clean-image" src="assets/img/cqrs_es_multiple.png" alt="CQRS/ES" />

                        <aside class="notes">
                            Ce cas n'est autre qu'un dérivé du précédent.
                            Par contre, là avons une séparation par métier.
                            Cela permet d'avoir une base commune (l'event store)
                            et les autres bases qui elles seront utilisées
                            par les applications qui pourront être hébergées dans des endroits différents.

                            Il est tout à fait possible d'avoir ce côté, multi-serveur avec des tables standards
                            comme dans le cas "décentralisé".
                        </aside>
                    </section>
                </section>

                <section id="comment_ca_marche">
                    <h1>Comment ça marche ?</h1>

                    <section>
                    </section>

                    <section id="declaration_connexion">
                        <h2>Déclaration de la connexion</h2>

                        <pre><code class="hlsql">
    CREATE EXTENSION postgres_fdw;
                        </code></pre>

                        <aside class="notes">
                            On déclare l'extension pour pouvoir l'utiliser dans PostgreSQL.
                            /!\ Nécessite certains droits utilisateurs.
                        </aside>
                    </section>

                    <section id="creation_connexion">
                        <h2>Création de la connexion</h2>

                        <pre><code class="hlsql">
    CREATE SERVER nom_remote
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'remote.url.lan',
        dbname 'ma_db'
    );
                        </code></pre>

                        <aside class="notes">
                            On créer le serveur distant.
                            D'autres options comme le port de connexion existent.
                        </aside>
                    </section>

                    <section id="mapping_utilisateur">
                        <h2>Mapping utilisateur</h2>

                        <pre><code class="hlsql">
    CREATE USER MAPPING FOR mon_local_user
        SERVER mon_remote
        OPTIONS (
            user 'mon_remote_user',
            password 'mon_remote_passwd'
        );
                        </code></pre>

                        <aside class="notes">
                            Les comptes utilisateurs ne sont pas forcément les mêmes
                            entre les deux instances.
                            Nous devons donc mapper notre utisateur local avec l'utilisateur distant.
                        </aside>
                    </section>

                    <section id="creation_table_distante">
                        <h2>Création d'une table distante</h2>

                        <pre><code class="hlsql">
    CREATE FOREIGN TABLE table_locale_mais_distante (
        id INTEGER,
        col1 VARCHAR(32),
        col2 BOOLEAN
    )
    SERVER mon_remote
    OPTIONS (
        table_name 'le_nom_de_ma_table',
        updatable 'false'
    );
                        </code></pre>

                        <aside class="notes">
                            La création d'une table étrangère se fait presque comme une table normale.
                            En plus du mot clef "FOREIGN"
                            nous devons spécifié le serveur sur lequelle est la table ainsi que quelques options.
                            Par défaut les tables distantes sont modifiables et le schema est 'public'.
                        </aside>
                    </section>

                    <section id="utilisation_table_distante">
                        <h2>Utilisation</h2>

                        <pre><code class="hlsql">
    SELECT id, col1
    FROM table_locale_mais_distante
    WHERE col2 IS TRUE
    ORDER BY col1;
                        </code></pre>

                        <aside class="notes">
                            Une fois la table correctement créée,
                            l'utilisation est la même qu'avec une table standard.
                        </aside>
                    </section>

                    <section id="encore_plus_facile">
                        <h2>Encore plus facile</h2>

                        <pre><code class="hsql">
    IMPORT FOREIGN SCHEMA schema_distant
    FROM SERVER mon_remote
    INTO mon_schema_local;
                        </code></pre>

                        <aside class="notes">
                            Depuis la version 9.5 de PostgreSQL,
                            nous avons la possibilité d'utiliser la commande
                            IMPORT FOREIGN SCHEMA qui va permettre
                            de récupérer les informations des tables distantes
                            et les transposer sur l'instance locale.
                        </aside>
                    </section>

                </section>

                <section id="exemple">
                    <h1>Exemple</h1>

                    <section id="exemple_presentation">

                        <p>
                            <a href="https://github.com/fferriere/20160622_presentation_pg_fdw">Projet Github</a>
                        </p>

                        <img id="pic-decentralisation-exemple" class="clean-image" src="assets/img/decentralisation.png" alt="décentralisation" />

                        <table>
                            <tr>
                                <td>
                                    <i>Server</i> = "Base principale"
                                </td>
                                <td>
                                    <i>Client</i> = "Web DB"
                                </td>
                            </tr>
                        </table>

                        <aside class="notes">
                            J'ai créer un projet avec 2 conteneurs docker
                            pour montrer l'utilisation des foreign data wrapper.
                            Le README.md explique comment l'utiliser.

                            Les exemples suivants sont tirés de ce projet.
                        </aside>

                    </section>

                    <section id="tables_server">
                        <h2>Tables sur <i>server</i></h2>

                        <pre><code class="hlsh">
    server=# \d
                    Liste des relations
     Schéma |       Nom       |   Type   | Propriétaire
    --------+-----------------+----------+--------------
     public | country         | table    | docker
     public | country_id_seq  | séquence | docker
     public | customer        | table    | docker
     public | customer_id_seq | séquence | docker
    (4 lignes)
                        </code></pre>

                        <aside class="notes">
                            Voici la liste des tables sur le serveur.
                            Nous avons une table country et une autre customer
                            ainsi que les sequence associée.
                        </aside>
                    </section>

                    <section id="description_table_server">
                        <h2>Table sur le <i>server</i></h2>

                        <pre><code class="hlsh">
    server=# \d country
                  Table « public.country »
     Colonne |         Type          | Modificateurs
    ---------+-----------------------+---------------
     id      | integer               | non NULL
     alpha2  | character(2)          | non NULL
     alpha3  | character(3)          | non NULL
     label   | character varying(64) | non NULL
    Index :
        "country_pkey" PRIMARY KEY, btree (id)
                        </code></pre>
                    </section>

                    <section id="select_table_server">
                        <h2>Table sur le <i>server</i></h2>

                        <pre><code class="hlsh">
    server=# SELECT count(id) FROM country;
     count
    -------
       241
    (1 ligne)

    server=# SELECT id, alpha2, alpha3, label
            FROM public.country
            WHERE alpha2 = 'FR';
     id | alpha2 | alpha3 | label
    ----+--------+--------+--------
     75 | FR     | FRA    | France
    (1 ligne)
                        </code></pre>

                        <aside class="notes">
                            Nous pouvons voir qu'il y a des données.
                        </aside>
                    </section>

                    <section id="tables_client">
                        <h2>Tables sur le <i>client</i></h2>

                        <pre><code class="hlsh">
    client=# \d
                    Liste des relations
    Schéma |    Nom     |       Type       | Propriétaire
    --------+------------+------------------+--------------
    public | f_country  | table distante   | docker
    public | f_customer | table distante   | docker
    public | m_customer | vue matérialisée | docker
    public | u_country  | table distante   | docker
    (4 lignes)
                        </code></pre>

                        <aside class="notes">
                            Ici nous avons listé les tables sur le client.
                            J'ai pour habitude de préfixer les tables étrangères par un f.
                            Pour l'exemple j'ai créer la table u_country,
                            c'est la même table que f_country mais updatable.
                            Nous pouvons voir qu'il y a une vue matériliasée.
                            Nous reviendrons dessus.
                        </aside>
                    </section>

                    <section id="description_table_client">
                        <h2>Table sur le <i>client</i></h2>

                        <pre><code class="hlsh">
    client=# \d f_country
                  Table distante « public.f_country »
     Colonne |         Type          | Modificateurs | Options FDW
    ---------+-----------------------+---------------+-------------
     id      | integer               |               |
     alpha2  | character(2)          |               |
     alpha3  | character(3)          |               |
     label   | character varying(64) |               |
    Server: server
    FDW Options: (
        schema_name 'public',
        table_name 'country',
        updatable 'false')
                        </code></pre>

                        <aside class="notes">
                            Nous avons une description de la table f_country,
                            à l'image de la table sur server.
                        </aside>
                    </section>

                    <section id="select_table_client">
                        <h2>Table sur le <i>client</i></h2>

                        <pre><code class="hlsh">
    client=# SELECT count(id) FROM f_country;
     count
    -------
       241
    (1 ligne)

    client=# SELECT id, alpha2, alpha3, label
            FROM public.f_country
            WHERE alpha2 = 'FR';
     id | alpha2 | alpha3 | label
    ----+--------+--------+--------
     75 | FR     | FRA    | France
    (1 ligne)
                        </code></pre>

                        <aside class="notes">
                            Nous pouvons voir qu'il y a les même données.
                        </aside>
                    </section>
                </section>

                <section id="vue_materialisee">
                    <h1>Vue matérialisée</h1>

                    <section id="creation_vue_materialisee">
                        <p class="fragment">Mélange entre une vue et une table</p>
                        <pre class="fragment"><code class="hlsql">
    CREATE MATERIALIZED VIEW m_customer AS
    SELECT id, lastname, firstname,
            date_part('year', age(birthday)) as age
    FROM f_customer
    WITH NO DATA;
    CREATE INDEX m_customer_keys
        ON m_customer (id);
                        </code></pre>
                        <pre class="fragment"><code class="hlsql">
    REFRESH MATERIALIZED VIEW m_customer;
                        </code></pre>

                        <aside class="notes">
                            Nous avons, ici, la requête de création de vue matérialisées.
                            Une vue matérialisées est entre une table et une vue.
                            La construction ce fait, comme une vue, à partir d'une requête.
                            Par contre les données sont stockées.
                            Ce qui fait que l'on peut ajouter des index.
                            Le fait d'avoir une construction par requête permet
                            de spécialiser les informations pour notre besoin.

                            L'option 'WITH NO DATA' est facultative,
                            elle permet de créer une vue sans charger les données.

                            Le rafraichissement des données d'une vue matérialisée
                            se fait, simplement, avec la commande 'REFRESH MATERIALIZED VIEW'.
                        </aside>
                    </section>

                    <section id="utilisation_vue_materialisee">
                        <pre><code class="hlsh">
    server=# SELECT id, lastname, firstname, birthday
            FROM customer LIMIT 2;
     id | lastname | firstname |  birthday
    ----+----------+-----------+------------
      1 | Potter   | Harry     | 1980-08-31
      2 | Weasley  | Ron       | 1980-03-01
    (2 lignes)

    client=# SELECT id, lastname, firstname, age
            FROM m_customer LIMIT 2;
     id | lastname | firstname | age
    ----+----------+-----------+-----
      1 | Potter   | Harry     |  35
      2 | Weasley  | Ron       |  36
    (2 lignes)
                        </code></pre>

                        <aside class="notes">
                            Nous pouvons voir que la vue matérialisée
                            retourne bien des données différentes
                            que la table initiale.
                        </aside>
                    </section>
                </section>

                <section id="cas_pratique">
                    <h1>Cas pratique</h1>

                    <section id="besoin">
                        <h2>Besoin</h2>

                        <p class="fragment">Application Web</p>
                        <p class="fragment">IBM AS400/DB2</p>
                        <p class="fragment">
                            <span class="fragment highlight-line-through">Driver PHP</span>
                        </p>
                        <p class="fragment">JDBC</p>
                        <p class="fragment">jdbc2_fdw</p>

                        <aside class="notes">
                            Je vais maintenant vous parler du cas pratique que j'ai pu mettre en place.
                            Voici une étude du besoin.

                            Le besoin était d'avoir une application web,
                            permettant à nos clients d'accéder à leurs informations.

                            Les données sont stockées sur un IBM/AS400 qui intègre un base DB2.
                            Premier problème le driver PHP-DB2 n'est pas facilement accessible, en tout cas sous Linux.
                            OS de notre hébergement.
                            J'ai réussi, tant bien que mal à le compiler, mais une fois fais j'avais une erreur de license.
                            Bienvenue dans le monde merveilleux d'IBM.

                            J'avais pu remarquer qu'avec un outils de DB SQL générique développé en Java (DBeaver),
                            j'avais un connecteur JDBC pour DB2.
                            Après configuration j'ai pu facilement accéder aux données sur le serveur.

                            C'est là que j'ai découvert les FDW et le <a href="https://github.com/heimir-sverrisson/jdbc2_fdw/">jdbc2_fdw</a>.
                            Après quelques essais plutôt concluant je me suis lancé.
                        </aside>
                    </section>

                    <section id="explication_cas_pratique">
                        <h2>Explication</h2>

                        <img id="as_400_proxy_web" class="clean-image" src="assets/img/as_400_proxy_web.png" alt="as_400_proxy_web" />

                        <aside class="notes">
                            Nous avons donc les données qui sont stockées sur l'AS400.

                            Nous avons aussi le serveur "proxy", va lui se connecter, via jdbc2_fdw, à l'AS400.
                            Ce serveur ne sert que de passe-plat entre l'AS400 et le serveur pour le Web.
                            Il permet de faire quelques conversions de données :
                            les dates n'étaient pas stockées dans un format de date sur l'AS400
                            ou les booléens étaient stockées comme des entiers, ...

                            Enfin nous avons la base de données pour l'appli Web.
                            Cette base de données va stocker des données qui lui sont propres.
                            Elle va aussi se connecter au serveur PostgreSQL nommé "proxy".
                        </aside>
                    </section>

                    <section id="rafraichissement_proxy">
                        <h2>Rafraichissement du proxy</h2>

                        <pre class="fragment"><code class="hlsql">
    CREATE FOREIGN TABLE f_ma_table (...) SERVER server OPTIONS (...);

    CREATE MATERIALIZED VIEW m_ma_table AS
    SELECT ... FROM f_ma_table;

    CREATE FUNCTION refresh_view(name) RETURNS INTEGER AS $$
    BEGIN
        EXECUTE format('REFRESH MATERIALIZED VIEW %s', name);
        RETURN 1;
    END;
    $$ LANGUAGE 'plpgsql';

    CREATE VIEW refresh_ma_table AS SELECT refresh_view('m_ma_table');
                        </code></pre>

                        <aside class="notes">
                            Nous avons besoin que nos données restent à jour.
                            Nous avons vu que mettre à jour une vue matérialisée est très simple.
                            Il suffit d'appeler la commande REFRESH MATERIALIZED VIEW.

                            Comme nous avions quelques conversions entre l'AS400 et le "proxy",
                            et pour éviter de garder la connexion avec l'AS400 trop longtemps,
                            les données sont enregistrées dans des vues matérialisés.
                            Cela nous permet aussi d'avoir des index personnalisés et
                            d'améliorer les performances.

                            J'ai mis en place l'appel du "refresh" au travers d'une fonction,
                            appelée dans une vue.
                            Cette vue pouvait être concidérée comme une table distante
                            sur l'instance web.
                            Avec cette technique, il est possible de gérer le rafraichissement
                            des données, depuis l'instance web.
                        </aside>
                    </section>

                    <section id="rafraichissement_web">
                        <h2>Refraichissement côté web</h2>

                        <p class="fragment">Deux vues matérialisées</p>
                        <p class="fragment">La première liée au "proxy"</p>
                        <p class="fragment">La seconde liée à la première</p>

                        <aside class="notes">
                            A l'image du serveur "proxy",
                            les tables distantes sont tamporisées dans des vues matérialisées.

                            Le problème est que si le refraichissement d'une vue matérialisée
                            verrouille son accès en lecture.
                            Du coup si un utilisateur accède à une page web
                            au moment où le refraichissement s'effectue,
                            le chargement de la page va être très long.

                            Du coup, pour réduire ce temps de verrouillage,
                            j'ai mis en place deux vues matérialisées.
                            La première vue récupére les données depuis le "proxy",
                            la seconde à partir de la première vue.
                            Le refraichissement de la seconde est très rapide
                            car les données sont déjà en local.
                        </aside>
                    </section>

                    <section id="complement1">
                        <h2>Complément (1/2)</h2>

                        <p class="fragment">Table de commande trop volumineuse</p>
                        <p class="fragment">Durée de rafraichissement > 20 minutes</p>
                        <p class="fragment">Besoin d'avoir des données de moins de 10 minutes</p>

                        <aside class="notes">
                            Certaines tables, comme les commandes,
                            peuvent contenir un nombre important de données.
                            Le rafraichissement pouvait prendre plusieurs dizaines de minutes.
                            Il n'est pas concevable de rafraichir ces données toutes les 10 minutes.
                            Il n'est malheureusement pas concevable que les données soient vieilles de plus de 10 minutes.
                        </aside>
                    </section>

                    <section id="complement2">
                        <h2>Complément (2/2)</h2>

                        <ul>
                            <li class="fragment">Découpage en 2 vues (proxy) :</li>
                            <li class="fragment">toutes les lignes</li>
                            <li class="fragment">les "dernières" commandes</li>
                        </ul>
                        <ul>
                            <li class="fragment">Récupération (web) :</li>
                            <li class="fragment">historique : une fois par jour</li>
                            <li class="fragment">"light" : toutes les 10 minutes</li>
                        </ul>
                        <p class="fragment">Fusion dans une 3ème vue</p>

                        <aside class="notes">
                            Du coup, il a fallu composer.

                            Sur le proxy j'ai découpé la table (distante) des commandes en 2 parties.
                            La première contient toutes les données,
                            elle servira de base et d'historique.
                            La seconde contient que les commandes de moins d'une semaine,
                            ou qui ne sont pas expédiées.
                            En gros, ce sont les commandes les plus importantes.

                            Ensuite sur l'instance web, nous allons pouvoir recharger ces deux tables distinctement dans des vues matérialisées.
                            La table d'historique est rafraichie tout les jours vers 2h du matin.
                            La seconde table, qui du coup, est bien plus légère peux alors être raffraichie toutes les 10 minutes.

                            Une fois ces deux tables raffraichies,
                            une troisième (et dernière) vue matérialisée est créée.
                            Elle fusionne les deux premières vues,
                            ce qui fait que nous avons une table de commandes complète.
                            Du coup, dans notre application nous n'avons qu'une seule table à gérer.
                        </aside>
                    </section>

                </section>

                <section id="merci">
                    <h1>Merci</h1>

                    <h2>Des questions ?</h2>
                </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                slideNumber: 'c/t',

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
